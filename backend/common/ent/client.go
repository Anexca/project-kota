// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"common/ent/migrate"

	"common/ent/cachedexam"
	"common/ent/exam"
	"common/ent/examassesment"
	"common/ent/examattempt"
	"common/ent/examcategory"
	"common/ent/examsetting"
	"common/ent/generatedexam"
	"common/ent/payment"
	"common/ent/subscription"
	"common/ent/subscriptionexam"
	"common/ent/user"
	"common/ent/usersubscription"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CachedExam is the client for interacting with the CachedExam builders.
	CachedExam *CachedExamClient
	// Exam is the client for interacting with the Exam builders.
	Exam *ExamClient
	// ExamAssesment is the client for interacting with the ExamAssesment builders.
	ExamAssesment *ExamAssesmentClient
	// ExamAttempt is the client for interacting with the ExamAttempt builders.
	ExamAttempt *ExamAttemptClient
	// ExamCategory is the client for interacting with the ExamCategory builders.
	ExamCategory *ExamCategoryClient
	// ExamSetting is the client for interacting with the ExamSetting builders.
	ExamSetting *ExamSettingClient
	// GeneratedExam is the client for interacting with the GeneratedExam builders.
	GeneratedExam *GeneratedExamClient
	// Payment is the client for interacting with the Payment builders.
	Payment *PaymentClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// SubscriptionExam is the client for interacting with the SubscriptionExam builders.
	SubscriptionExam *SubscriptionExamClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserSubscription is the client for interacting with the UserSubscription builders.
	UserSubscription *UserSubscriptionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CachedExam = NewCachedExamClient(c.config)
	c.Exam = NewExamClient(c.config)
	c.ExamAssesment = NewExamAssesmentClient(c.config)
	c.ExamAttempt = NewExamAttemptClient(c.config)
	c.ExamCategory = NewExamCategoryClient(c.config)
	c.ExamSetting = NewExamSettingClient(c.config)
	c.GeneratedExam = NewGeneratedExamClient(c.config)
	c.Payment = NewPaymentClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.SubscriptionExam = NewSubscriptionExamClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserSubscription = NewUserSubscriptionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		CachedExam:       NewCachedExamClient(cfg),
		Exam:             NewExamClient(cfg),
		ExamAssesment:    NewExamAssesmentClient(cfg),
		ExamAttempt:      NewExamAttemptClient(cfg),
		ExamCategory:     NewExamCategoryClient(cfg),
		ExamSetting:      NewExamSettingClient(cfg),
		GeneratedExam:    NewGeneratedExamClient(cfg),
		Payment:          NewPaymentClient(cfg),
		Subscription:     NewSubscriptionClient(cfg),
		SubscriptionExam: NewSubscriptionExamClient(cfg),
		User:             NewUserClient(cfg),
		UserSubscription: NewUserSubscriptionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		CachedExam:       NewCachedExamClient(cfg),
		Exam:             NewExamClient(cfg),
		ExamAssesment:    NewExamAssesmentClient(cfg),
		ExamAttempt:      NewExamAttemptClient(cfg),
		ExamCategory:     NewExamCategoryClient(cfg),
		ExamSetting:      NewExamSettingClient(cfg),
		GeneratedExam:    NewGeneratedExamClient(cfg),
		Payment:          NewPaymentClient(cfg),
		Subscription:     NewSubscriptionClient(cfg),
		SubscriptionExam: NewSubscriptionExamClient(cfg),
		User:             NewUserClient(cfg),
		UserSubscription: NewUserSubscriptionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CachedExam.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.CachedExam, c.Exam, c.ExamAssesment, c.ExamAttempt, c.ExamCategory,
		c.ExamSetting, c.GeneratedExam, c.Payment, c.Subscription, c.SubscriptionExam,
		c.User, c.UserSubscription,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.CachedExam, c.Exam, c.ExamAssesment, c.ExamAttempt, c.ExamCategory,
		c.ExamSetting, c.GeneratedExam, c.Payment, c.Subscription, c.SubscriptionExam,
		c.User, c.UserSubscription,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CachedExamMutation:
		return c.CachedExam.mutate(ctx, m)
	case *ExamMutation:
		return c.Exam.mutate(ctx, m)
	case *ExamAssesmentMutation:
		return c.ExamAssesment.mutate(ctx, m)
	case *ExamAttemptMutation:
		return c.ExamAttempt.mutate(ctx, m)
	case *ExamCategoryMutation:
		return c.ExamCategory.mutate(ctx, m)
	case *ExamSettingMutation:
		return c.ExamSetting.mutate(ctx, m)
	case *GeneratedExamMutation:
		return c.GeneratedExam.mutate(ctx, m)
	case *PaymentMutation:
		return c.Payment.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *SubscriptionExamMutation:
		return c.SubscriptionExam.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserSubscriptionMutation:
		return c.UserSubscription.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CachedExamClient is a client for the CachedExam schema.
type CachedExamClient struct {
	config
}

// NewCachedExamClient returns a client for the CachedExam from the given config.
func NewCachedExamClient(c config) *CachedExamClient {
	return &CachedExamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cachedexam.Hooks(f(g(h())))`.
func (c *CachedExamClient) Use(hooks ...Hook) {
	c.hooks.CachedExam = append(c.hooks.CachedExam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cachedexam.Intercept(f(g(h())))`.
func (c *CachedExamClient) Intercept(interceptors ...Interceptor) {
	c.inters.CachedExam = append(c.inters.CachedExam, interceptors...)
}

// Create returns a builder for creating a CachedExam entity.
func (c *CachedExamClient) Create() *CachedExamCreate {
	mutation := newCachedExamMutation(c.config, OpCreate)
	return &CachedExamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CachedExam entities.
func (c *CachedExamClient) CreateBulk(builders ...*CachedExamCreate) *CachedExamCreateBulk {
	return &CachedExamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CachedExamClient) MapCreateBulk(slice any, setFunc func(*CachedExamCreate, int)) *CachedExamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CachedExamCreateBulk{err: fmt.Errorf("calling to CachedExamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CachedExamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CachedExamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CachedExam.
func (c *CachedExamClient) Update() *CachedExamUpdate {
	mutation := newCachedExamMutation(c.config, OpUpdate)
	return &CachedExamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CachedExamClient) UpdateOne(ce *CachedExam) *CachedExamUpdateOne {
	mutation := newCachedExamMutation(c.config, OpUpdateOne, withCachedExam(ce))
	return &CachedExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CachedExamClient) UpdateOneID(id int) *CachedExamUpdateOne {
	mutation := newCachedExamMutation(c.config, OpUpdateOne, withCachedExamID(id))
	return &CachedExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CachedExam.
func (c *CachedExamClient) Delete() *CachedExamDelete {
	mutation := newCachedExamMutation(c.config, OpDelete)
	return &CachedExamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CachedExamClient) DeleteOne(ce *CachedExam) *CachedExamDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CachedExamClient) DeleteOneID(id int) *CachedExamDeleteOne {
	builder := c.Delete().Where(cachedexam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CachedExamDeleteOne{builder}
}

// Query returns a query builder for CachedExam.
func (c *CachedExamClient) Query() *CachedExamQuery {
	return &CachedExamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCachedExam},
		inters: c.Interceptors(),
	}
}

// Get returns a CachedExam entity by its id.
func (c *CachedExamClient) Get(ctx context.Context, id int) (*CachedExam, error) {
	return c.Query().Where(cachedexam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CachedExamClient) GetX(ctx context.Context, id int) *CachedExam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a CachedExam.
func (c *CachedExamClient) QueryExam(ce *CachedExam) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cachedexam.Table, cachedexam.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cachedexam.ExamTable, cachedexam.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CachedExamClient) Hooks() []Hook {
	return c.hooks.CachedExam
}

// Interceptors returns the client interceptors.
func (c *CachedExamClient) Interceptors() []Interceptor {
	return c.inters.CachedExam
}

func (c *CachedExamClient) mutate(ctx context.Context, m *CachedExamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CachedExamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CachedExamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CachedExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CachedExamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CachedExam mutation op: %q", m.Op())
	}
}

// ExamClient is a client for the Exam schema.
type ExamClient struct {
	config
}

// NewExamClient returns a client for the Exam from the given config.
func NewExamClient(c config) *ExamClient {
	return &ExamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exam.Hooks(f(g(h())))`.
func (c *ExamClient) Use(hooks ...Hook) {
	c.hooks.Exam = append(c.hooks.Exam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exam.Intercept(f(g(h())))`.
func (c *ExamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Exam = append(c.inters.Exam, interceptors...)
}

// Create returns a builder for creating a Exam entity.
func (c *ExamClient) Create() *ExamCreate {
	mutation := newExamMutation(c.config, OpCreate)
	return &ExamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Exam entities.
func (c *ExamClient) CreateBulk(builders ...*ExamCreate) *ExamCreateBulk {
	return &ExamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamClient) MapCreateBulk(slice any, setFunc func(*ExamCreate, int)) *ExamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamCreateBulk{err: fmt.Errorf("calling to ExamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Exam.
func (c *ExamClient) Update() *ExamUpdate {
	mutation := newExamMutation(c.config, OpUpdate)
	return &ExamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamClient) UpdateOne(e *Exam) *ExamUpdateOne {
	mutation := newExamMutation(c.config, OpUpdateOne, withExam(e))
	return &ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamClient) UpdateOneID(id int) *ExamUpdateOne {
	mutation := newExamMutation(c.config, OpUpdateOne, withExamID(id))
	return &ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Exam.
func (c *ExamClient) Delete() *ExamDelete {
	mutation := newExamMutation(c.config, OpDelete)
	return &ExamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamClient) DeleteOne(e *Exam) *ExamDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamClient) DeleteOneID(id int) *ExamDeleteOne {
	builder := c.Delete().Where(exam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamDeleteOne{builder}
}

// Query returns a query builder for Exam.
func (c *ExamClient) Query() *ExamQuery {
	return &ExamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExam},
		inters: c.Interceptors(),
	}
}

// Get returns a Exam entity by its id.
func (c *ExamClient) Get(ctx context.Context, id int) (*Exam, error) {
	return c.Query().Where(exam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamClient) GetX(ctx context.Context, id int) *Exam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategory queries the category edge of a Exam.
func (c *ExamClient) QueryCategory(e *Exam) *ExamCategoryQuery {
	query := (&ExamCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(examcategory.Table, examcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, exam.CategoryTable, exam.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a Exam.
func (c *ExamClient) QuerySubscriptions(e *Exam) *SubscriptionExamQuery {
	query := (&SubscriptionExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(subscriptionexam.Table, subscriptionexam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.SubscriptionsTable, exam.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a Exam.
func (c *ExamClient) QuerySetting(e *Exam) *ExamSettingQuery {
	query := (&ExamSettingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(examsetting.Table, examsetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, exam.SettingTable, exam.SettingColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCachedExam queries the cached_exam edge of a Exam.
func (c *ExamClient) QueryCachedExam(e *Exam) *CachedExamQuery {
	query := (&CachedExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(cachedexam.Table, cachedexam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.CachedExamTable, exam.CachedExamColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGeneratedexams queries the generatedexams edge of a Exam.
func (c *ExamClient) QueryGeneratedexams(e *Exam) *GeneratedExamQuery {
	query := (&GeneratedExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(generatedexam.Table, generatedexam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.GeneratedexamsTable, exam.GeneratedexamsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamClient) Hooks() []Hook {
	return c.hooks.Exam
}

// Interceptors returns the client interceptors.
func (c *ExamClient) Interceptors() []Interceptor {
	return c.inters.Exam
}

func (c *ExamClient) mutate(ctx context.Context, m *ExamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Exam mutation op: %q", m.Op())
	}
}

// ExamAssesmentClient is a client for the ExamAssesment schema.
type ExamAssesmentClient struct {
	config
}

// NewExamAssesmentClient returns a client for the ExamAssesment from the given config.
func NewExamAssesmentClient(c config) *ExamAssesmentClient {
	return &ExamAssesmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examassesment.Hooks(f(g(h())))`.
func (c *ExamAssesmentClient) Use(hooks ...Hook) {
	c.hooks.ExamAssesment = append(c.hooks.ExamAssesment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examassesment.Intercept(f(g(h())))`.
func (c *ExamAssesmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamAssesment = append(c.inters.ExamAssesment, interceptors...)
}

// Create returns a builder for creating a ExamAssesment entity.
func (c *ExamAssesmentClient) Create() *ExamAssesmentCreate {
	mutation := newExamAssesmentMutation(c.config, OpCreate)
	return &ExamAssesmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamAssesment entities.
func (c *ExamAssesmentClient) CreateBulk(builders ...*ExamAssesmentCreate) *ExamAssesmentCreateBulk {
	return &ExamAssesmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamAssesmentClient) MapCreateBulk(slice any, setFunc func(*ExamAssesmentCreate, int)) *ExamAssesmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamAssesmentCreateBulk{err: fmt.Errorf("calling to ExamAssesmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamAssesmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamAssesmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamAssesment.
func (c *ExamAssesmentClient) Update() *ExamAssesmentUpdate {
	mutation := newExamAssesmentMutation(c.config, OpUpdate)
	return &ExamAssesmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamAssesmentClient) UpdateOne(ea *ExamAssesment) *ExamAssesmentUpdateOne {
	mutation := newExamAssesmentMutation(c.config, OpUpdateOne, withExamAssesment(ea))
	return &ExamAssesmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamAssesmentClient) UpdateOneID(id int) *ExamAssesmentUpdateOne {
	mutation := newExamAssesmentMutation(c.config, OpUpdateOne, withExamAssesmentID(id))
	return &ExamAssesmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamAssesment.
func (c *ExamAssesmentClient) Delete() *ExamAssesmentDelete {
	mutation := newExamAssesmentMutation(c.config, OpDelete)
	return &ExamAssesmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamAssesmentClient) DeleteOne(ea *ExamAssesment) *ExamAssesmentDeleteOne {
	return c.DeleteOneID(ea.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamAssesmentClient) DeleteOneID(id int) *ExamAssesmentDeleteOne {
	builder := c.Delete().Where(examassesment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamAssesmentDeleteOne{builder}
}

// Query returns a query builder for ExamAssesment.
func (c *ExamAssesmentClient) Query() *ExamAssesmentQuery {
	return &ExamAssesmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamAssesment},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamAssesment entity by its id.
func (c *ExamAssesmentClient) Get(ctx context.Context, id int) (*ExamAssesment, error) {
	return c.Query().Where(examassesment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamAssesmentClient) GetX(ctx context.Context, id int) *ExamAssesment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttempt queries the attempt edge of a ExamAssesment.
func (c *ExamAssesmentClient) QueryAttempt(ea *ExamAssesment) *ExamAttemptQuery {
	query := (&ExamAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examassesment.Table, examassesment.FieldID, id),
			sqlgraph.To(examattempt.Table, examattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, examassesment.AttemptTable, examassesment.AttemptColumn),
		)
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamAssesmentClient) Hooks() []Hook {
	return c.hooks.ExamAssesment
}

// Interceptors returns the client interceptors.
func (c *ExamAssesmentClient) Interceptors() []Interceptor {
	return c.inters.ExamAssesment
}

func (c *ExamAssesmentClient) mutate(ctx context.Context, m *ExamAssesmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamAssesmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamAssesmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamAssesmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamAssesmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamAssesment mutation op: %q", m.Op())
	}
}

// ExamAttemptClient is a client for the ExamAttempt schema.
type ExamAttemptClient struct {
	config
}

// NewExamAttemptClient returns a client for the ExamAttempt from the given config.
func NewExamAttemptClient(c config) *ExamAttemptClient {
	return &ExamAttemptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examattempt.Hooks(f(g(h())))`.
func (c *ExamAttemptClient) Use(hooks ...Hook) {
	c.hooks.ExamAttempt = append(c.hooks.ExamAttempt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examattempt.Intercept(f(g(h())))`.
func (c *ExamAttemptClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamAttempt = append(c.inters.ExamAttempt, interceptors...)
}

// Create returns a builder for creating a ExamAttempt entity.
func (c *ExamAttemptClient) Create() *ExamAttemptCreate {
	mutation := newExamAttemptMutation(c.config, OpCreate)
	return &ExamAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamAttempt entities.
func (c *ExamAttemptClient) CreateBulk(builders ...*ExamAttemptCreate) *ExamAttemptCreateBulk {
	return &ExamAttemptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamAttemptClient) MapCreateBulk(slice any, setFunc func(*ExamAttemptCreate, int)) *ExamAttemptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamAttemptCreateBulk{err: fmt.Errorf("calling to ExamAttemptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamAttemptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamAttemptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamAttempt.
func (c *ExamAttemptClient) Update() *ExamAttemptUpdate {
	mutation := newExamAttemptMutation(c.config, OpUpdate)
	return &ExamAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamAttemptClient) UpdateOne(ea *ExamAttempt) *ExamAttemptUpdateOne {
	mutation := newExamAttemptMutation(c.config, OpUpdateOne, withExamAttempt(ea))
	return &ExamAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamAttemptClient) UpdateOneID(id int) *ExamAttemptUpdateOne {
	mutation := newExamAttemptMutation(c.config, OpUpdateOne, withExamAttemptID(id))
	return &ExamAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamAttempt.
func (c *ExamAttemptClient) Delete() *ExamAttemptDelete {
	mutation := newExamAttemptMutation(c.config, OpDelete)
	return &ExamAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamAttemptClient) DeleteOne(ea *ExamAttempt) *ExamAttemptDeleteOne {
	return c.DeleteOneID(ea.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamAttemptClient) DeleteOneID(id int) *ExamAttemptDeleteOne {
	builder := c.Delete().Where(examattempt.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamAttemptDeleteOne{builder}
}

// Query returns a query builder for ExamAttempt.
func (c *ExamAttemptClient) Query() *ExamAttemptQuery {
	return &ExamAttemptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamAttempt},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamAttempt entity by its id.
func (c *ExamAttemptClient) Get(ctx context.Context, id int) (*ExamAttempt, error) {
	return c.Query().Where(examattempt.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamAttemptClient) GetX(ctx context.Context, id int) *ExamAttempt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGeneratedexam queries the generatedexam edge of a ExamAttempt.
func (c *ExamAttemptClient) QueryGeneratedexam(ea *ExamAttempt) *GeneratedExamQuery {
	query := (&GeneratedExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examattempt.Table, examattempt.FieldID, id),
			sqlgraph.To(generatedexam.Table, generatedexam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, examattempt.GeneratedexamTable, examattempt.GeneratedexamColumn),
		)
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ExamAttempt.
func (c *ExamAttemptClient) QueryUser(ea *ExamAttempt) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examattempt.Table, examattempt.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, examattempt.UserTable, examattempt.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssesment queries the assesment edge of a ExamAttempt.
func (c *ExamAttemptClient) QueryAssesment(ea *ExamAttempt) *ExamAssesmentQuery {
	query := (&ExamAssesmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examattempt.Table, examattempt.FieldID, id),
			sqlgraph.To(examassesment.Table, examassesment.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, examattempt.AssesmentTable, examattempt.AssesmentColumn),
		)
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamAttemptClient) Hooks() []Hook {
	return c.hooks.ExamAttempt
}

// Interceptors returns the client interceptors.
func (c *ExamAttemptClient) Interceptors() []Interceptor {
	return c.inters.ExamAttempt
}

func (c *ExamAttemptClient) mutate(ctx context.Context, m *ExamAttemptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamAttemptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamAttemptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamAttemptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamAttemptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamAttempt mutation op: %q", m.Op())
	}
}

// ExamCategoryClient is a client for the ExamCategory schema.
type ExamCategoryClient struct {
	config
}

// NewExamCategoryClient returns a client for the ExamCategory from the given config.
func NewExamCategoryClient(c config) *ExamCategoryClient {
	return &ExamCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examcategory.Hooks(f(g(h())))`.
func (c *ExamCategoryClient) Use(hooks ...Hook) {
	c.hooks.ExamCategory = append(c.hooks.ExamCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examcategory.Intercept(f(g(h())))`.
func (c *ExamCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamCategory = append(c.inters.ExamCategory, interceptors...)
}

// Create returns a builder for creating a ExamCategory entity.
func (c *ExamCategoryClient) Create() *ExamCategoryCreate {
	mutation := newExamCategoryMutation(c.config, OpCreate)
	return &ExamCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamCategory entities.
func (c *ExamCategoryClient) CreateBulk(builders ...*ExamCategoryCreate) *ExamCategoryCreateBulk {
	return &ExamCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamCategoryClient) MapCreateBulk(slice any, setFunc func(*ExamCategoryCreate, int)) *ExamCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamCategoryCreateBulk{err: fmt.Errorf("calling to ExamCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamCategory.
func (c *ExamCategoryClient) Update() *ExamCategoryUpdate {
	mutation := newExamCategoryMutation(c.config, OpUpdate)
	return &ExamCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamCategoryClient) UpdateOne(ec *ExamCategory) *ExamCategoryUpdateOne {
	mutation := newExamCategoryMutation(c.config, OpUpdateOne, withExamCategory(ec))
	return &ExamCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamCategoryClient) UpdateOneID(id int) *ExamCategoryUpdateOne {
	mutation := newExamCategoryMutation(c.config, OpUpdateOne, withExamCategoryID(id))
	return &ExamCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamCategory.
func (c *ExamCategoryClient) Delete() *ExamCategoryDelete {
	mutation := newExamCategoryMutation(c.config, OpDelete)
	return &ExamCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamCategoryClient) DeleteOne(ec *ExamCategory) *ExamCategoryDeleteOne {
	return c.DeleteOneID(ec.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamCategoryClient) DeleteOneID(id int) *ExamCategoryDeleteOne {
	builder := c.Delete().Where(examcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamCategoryDeleteOne{builder}
}

// Query returns a query builder for ExamCategory.
func (c *ExamCategoryClient) Query() *ExamCategoryQuery {
	return &ExamCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamCategory entity by its id.
func (c *ExamCategoryClient) Get(ctx context.Context, id int) (*ExamCategory, error) {
	return c.Query().Where(examcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamCategoryClient) GetX(ctx context.Context, id int) *ExamCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExams queries the exams edge of a ExamCategory.
func (c *ExamCategoryClient) QueryExams(ec *ExamCategory) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ec.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examcategory.Table, examcategory.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, examcategory.ExamsTable, examcategory.ExamsColumn),
		)
		fromV = sqlgraph.Neighbors(ec.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamCategoryClient) Hooks() []Hook {
	return c.hooks.ExamCategory
}

// Interceptors returns the client interceptors.
func (c *ExamCategoryClient) Interceptors() []Interceptor {
	return c.inters.ExamCategory
}

func (c *ExamCategoryClient) mutate(ctx context.Context, m *ExamCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamCategory mutation op: %q", m.Op())
	}
}

// ExamSettingClient is a client for the ExamSetting schema.
type ExamSettingClient struct {
	config
}

// NewExamSettingClient returns a client for the ExamSetting from the given config.
func NewExamSettingClient(c config) *ExamSettingClient {
	return &ExamSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `examsetting.Hooks(f(g(h())))`.
func (c *ExamSettingClient) Use(hooks ...Hook) {
	c.hooks.ExamSetting = append(c.hooks.ExamSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `examsetting.Intercept(f(g(h())))`.
func (c *ExamSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExamSetting = append(c.inters.ExamSetting, interceptors...)
}

// Create returns a builder for creating a ExamSetting entity.
func (c *ExamSettingClient) Create() *ExamSettingCreate {
	mutation := newExamSettingMutation(c.config, OpCreate)
	return &ExamSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExamSetting entities.
func (c *ExamSettingClient) CreateBulk(builders ...*ExamSettingCreate) *ExamSettingCreateBulk {
	return &ExamSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamSettingClient) MapCreateBulk(slice any, setFunc func(*ExamSettingCreate, int)) *ExamSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamSettingCreateBulk{err: fmt.Errorf("calling to ExamSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExamSetting.
func (c *ExamSettingClient) Update() *ExamSettingUpdate {
	mutation := newExamSettingMutation(c.config, OpUpdate)
	return &ExamSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamSettingClient) UpdateOne(es *ExamSetting) *ExamSettingUpdateOne {
	mutation := newExamSettingMutation(c.config, OpUpdateOne, withExamSetting(es))
	return &ExamSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamSettingClient) UpdateOneID(id int) *ExamSettingUpdateOne {
	mutation := newExamSettingMutation(c.config, OpUpdateOne, withExamSettingID(id))
	return &ExamSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExamSetting.
func (c *ExamSettingClient) Delete() *ExamSettingDelete {
	mutation := newExamSettingMutation(c.config, OpDelete)
	return &ExamSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamSettingClient) DeleteOne(es *ExamSetting) *ExamSettingDeleteOne {
	return c.DeleteOneID(es.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamSettingClient) DeleteOneID(id int) *ExamSettingDeleteOne {
	builder := c.Delete().Where(examsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamSettingDeleteOne{builder}
}

// Query returns a query builder for ExamSetting.
func (c *ExamSettingClient) Query() *ExamSettingQuery {
	return &ExamSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExamSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a ExamSetting entity by its id.
func (c *ExamSettingClient) Get(ctx context.Context, id int) (*ExamSetting, error) {
	return c.Query().Where(examsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamSettingClient) GetX(ctx context.Context, id int) *ExamSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a ExamSetting.
func (c *ExamSettingClient) QueryExam(es *ExamSetting) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := es.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(examsetting.Table, examsetting.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, examsetting.ExamTable, examsetting.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(es.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamSettingClient) Hooks() []Hook {
	return c.hooks.ExamSetting
}

// Interceptors returns the client interceptors.
func (c *ExamSettingClient) Interceptors() []Interceptor {
	return c.inters.ExamSetting
}

func (c *ExamSettingClient) mutate(ctx context.Context, m *ExamSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExamSetting mutation op: %q", m.Op())
	}
}

// GeneratedExamClient is a client for the GeneratedExam schema.
type GeneratedExamClient struct {
	config
}

// NewGeneratedExamClient returns a client for the GeneratedExam from the given config.
func NewGeneratedExamClient(c config) *GeneratedExamClient {
	return &GeneratedExamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `generatedexam.Hooks(f(g(h())))`.
func (c *GeneratedExamClient) Use(hooks ...Hook) {
	c.hooks.GeneratedExam = append(c.hooks.GeneratedExam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `generatedexam.Intercept(f(g(h())))`.
func (c *GeneratedExamClient) Intercept(interceptors ...Interceptor) {
	c.inters.GeneratedExam = append(c.inters.GeneratedExam, interceptors...)
}

// Create returns a builder for creating a GeneratedExam entity.
func (c *GeneratedExamClient) Create() *GeneratedExamCreate {
	mutation := newGeneratedExamMutation(c.config, OpCreate)
	return &GeneratedExamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GeneratedExam entities.
func (c *GeneratedExamClient) CreateBulk(builders ...*GeneratedExamCreate) *GeneratedExamCreateBulk {
	return &GeneratedExamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GeneratedExamClient) MapCreateBulk(slice any, setFunc func(*GeneratedExamCreate, int)) *GeneratedExamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GeneratedExamCreateBulk{err: fmt.Errorf("calling to GeneratedExamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GeneratedExamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GeneratedExamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GeneratedExam.
func (c *GeneratedExamClient) Update() *GeneratedExamUpdate {
	mutation := newGeneratedExamMutation(c.config, OpUpdate)
	return &GeneratedExamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GeneratedExamClient) UpdateOne(ge *GeneratedExam) *GeneratedExamUpdateOne {
	mutation := newGeneratedExamMutation(c.config, OpUpdateOne, withGeneratedExam(ge))
	return &GeneratedExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GeneratedExamClient) UpdateOneID(id int) *GeneratedExamUpdateOne {
	mutation := newGeneratedExamMutation(c.config, OpUpdateOne, withGeneratedExamID(id))
	return &GeneratedExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GeneratedExam.
func (c *GeneratedExamClient) Delete() *GeneratedExamDelete {
	mutation := newGeneratedExamMutation(c.config, OpDelete)
	return &GeneratedExamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GeneratedExamClient) DeleteOne(ge *GeneratedExam) *GeneratedExamDeleteOne {
	return c.DeleteOneID(ge.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GeneratedExamClient) DeleteOneID(id int) *GeneratedExamDeleteOne {
	builder := c.Delete().Where(generatedexam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GeneratedExamDeleteOne{builder}
}

// Query returns a query builder for GeneratedExam.
func (c *GeneratedExamClient) Query() *GeneratedExamQuery {
	return &GeneratedExamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGeneratedExam},
		inters: c.Interceptors(),
	}
}

// Get returns a GeneratedExam entity by its id.
func (c *GeneratedExamClient) Get(ctx context.Context, id int) (*GeneratedExam, error) {
	return c.Query().Where(generatedexam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GeneratedExamClient) GetX(ctx context.Context, id int) *GeneratedExam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a GeneratedExam.
func (c *GeneratedExamClient) QueryExam(ge *GeneratedExam) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generatedexam.Table, generatedexam.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generatedexam.ExamTable, generatedexam.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttempts queries the attempts edge of a GeneratedExam.
func (c *GeneratedExamClient) QueryAttempts(ge *GeneratedExam) *ExamAttemptQuery {
	query := (&ExamAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ge.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generatedexam.Table, generatedexam.FieldID, id),
			sqlgraph.To(examattempt.Table, examattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, generatedexam.AttemptsTable, generatedexam.AttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(ge.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GeneratedExamClient) Hooks() []Hook {
	return c.hooks.GeneratedExam
}

// Interceptors returns the client interceptors.
func (c *GeneratedExamClient) Interceptors() []Interceptor {
	return c.inters.GeneratedExam
}

func (c *GeneratedExamClient) mutate(ctx context.Context, m *GeneratedExamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GeneratedExamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GeneratedExamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GeneratedExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GeneratedExamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GeneratedExam mutation op: %q", m.Op())
	}
}

// PaymentClient is a client for the Payment schema.
type PaymentClient struct {
	config
}

// NewPaymentClient returns a client for the Payment from the given config.
func NewPaymentClient(c config) *PaymentClient {
	return &PaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `payment.Hooks(f(g(h())))`.
func (c *PaymentClient) Use(hooks ...Hook) {
	c.hooks.Payment = append(c.hooks.Payment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `payment.Intercept(f(g(h())))`.
func (c *PaymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Payment = append(c.inters.Payment, interceptors...)
}

// Create returns a builder for creating a Payment entity.
func (c *PaymentClient) Create() *PaymentCreate {
	mutation := newPaymentMutation(c.config, OpCreate)
	return &PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Payment entities.
func (c *PaymentClient) CreateBulk(builders ...*PaymentCreate) *PaymentCreateBulk {
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentClient) MapCreateBulk(slice any, setFunc func(*PaymentCreate, int)) *PaymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentCreateBulk{err: fmt.Errorf("calling to PaymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Payment.
func (c *PaymentClient) Update() *PaymentUpdate {
	mutation := newPaymentMutation(c.config, OpUpdate)
	return &PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentClient) UpdateOne(pa *Payment) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPayment(pa))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentClient) UpdateOneID(id int) *PaymentUpdateOne {
	mutation := newPaymentMutation(c.config, OpUpdateOne, withPaymentID(id))
	return &PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Payment.
func (c *PaymentClient) Delete() *PaymentDelete {
	mutation := newPaymentMutation(c.config, OpDelete)
	return &PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentClient) DeleteOne(pa *Payment) *PaymentDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentClient) DeleteOneID(id int) *PaymentDeleteOne {
	builder := c.Delete().Where(payment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentDeleteOne{builder}
}

// Query returns a query builder for Payment.
func (c *PaymentClient) Query() *PaymentQuery {
	return &PaymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayment},
		inters: c.Interceptors(),
	}
}

// Get returns a Payment entity by its id.
func (c *PaymentClient) Get(ctx context.Context, id int) (*Payment, error) {
	return c.Query().Where(payment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentClient) GetX(ctx context.Context, id int) *Payment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Payment.
func (c *PaymentClient) QueryUser(pa *Payment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.UserTable, payment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscription queries the subscription edge of a Payment.
func (c *PaymentClient) QuerySubscription(pa *Payment) *UserSubscriptionQuery {
	query := (&UserSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(payment.Table, payment.FieldID, id),
			sqlgraph.To(usersubscription.Table, usersubscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, payment.SubscriptionTable, payment.SubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PaymentClient) Hooks() []Hook {
	return c.hooks.Payment
}

// Interceptors returns the client interceptors.
func (c *PaymentClient) Interceptors() []Interceptor {
	return c.inters.Payment
}

func (c *PaymentClient) mutate(ctx context.Context, m *PaymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Payment mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(s *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(s))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id int) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(s *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id int) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id int) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id int) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExams queries the exams edge of a Subscription.
func (c *SubscriptionClient) QueryExams(s *Subscription) *SubscriptionExamQuery {
	query := (&SubscriptionExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(subscriptionexam.Table, subscriptionexam.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subscription.ExamsTable, subscription.ExamsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserSubscriptions queries the user_subscriptions edge of a Subscription.
func (c *SubscriptionClient) QueryUserSubscriptions(s *Subscription) *UserSubscriptionQuery {
	query := (&UserSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(usersubscription.Table, usersubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, subscription.UserSubscriptionsTable, subscription.UserSubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// SubscriptionExamClient is a client for the SubscriptionExam schema.
type SubscriptionExamClient struct {
	config
}

// NewSubscriptionExamClient returns a client for the SubscriptionExam from the given config.
func NewSubscriptionExamClient(c config) *SubscriptionExamClient {
	return &SubscriptionExamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscriptionexam.Hooks(f(g(h())))`.
func (c *SubscriptionExamClient) Use(hooks ...Hook) {
	c.hooks.SubscriptionExam = append(c.hooks.SubscriptionExam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscriptionexam.Intercept(f(g(h())))`.
func (c *SubscriptionExamClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubscriptionExam = append(c.inters.SubscriptionExam, interceptors...)
}

// Create returns a builder for creating a SubscriptionExam entity.
func (c *SubscriptionExamClient) Create() *SubscriptionExamCreate {
	mutation := newSubscriptionExamMutation(c.config, OpCreate)
	return &SubscriptionExamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubscriptionExam entities.
func (c *SubscriptionExamClient) CreateBulk(builders ...*SubscriptionExamCreate) *SubscriptionExamCreateBulk {
	return &SubscriptionExamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionExamClient) MapCreateBulk(slice any, setFunc func(*SubscriptionExamCreate, int)) *SubscriptionExamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionExamCreateBulk{err: fmt.Errorf("calling to SubscriptionExamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionExamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionExamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubscriptionExam.
func (c *SubscriptionExamClient) Update() *SubscriptionExamUpdate {
	mutation := newSubscriptionExamMutation(c.config, OpUpdate)
	return &SubscriptionExamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionExamClient) UpdateOne(se *SubscriptionExam) *SubscriptionExamUpdateOne {
	mutation := newSubscriptionExamMutation(c.config, OpUpdateOne, withSubscriptionExam(se))
	return &SubscriptionExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionExamClient) UpdateOneID(id int) *SubscriptionExamUpdateOne {
	mutation := newSubscriptionExamMutation(c.config, OpUpdateOne, withSubscriptionExamID(id))
	return &SubscriptionExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubscriptionExam.
func (c *SubscriptionExamClient) Delete() *SubscriptionExamDelete {
	mutation := newSubscriptionExamMutation(c.config, OpDelete)
	return &SubscriptionExamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionExamClient) DeleteOne(se *SubscriptionExam) *SubscriptionExamDeleteOne {
	return c.DeleteOneID(se.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionExamClient) DeleteOneID(id int) *SubscriptionExamDeleteOne {
	builder := c.Delete().Where(subscriptionexam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionExamDeleteOne{builder}
}

// Query returns a query builder for SubscriptionExam.
func (c *SubscriptionExamClient) Query() *SubscriptionExamQuery {
	return &SubscriptionExamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscriptionExam},
		inters: c.Interceptors(),
	}
}

// Get returns a SubscriptionExam entity by its id.
func (c *SubscriptionExamClient) Get(ctx context.Context, id int) (*SubscriptionExam, error) {
	return c.Query().Where(subscriptionexam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionExamClient) GetX(ctx context.Context, id int) *SubscriptionExam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscription queries the subscription edge of a SubscriptionExam.
func (c *SubscriptionExamClient) QuerySubscription(se *SubscriptionExam) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscriptionexam.Table, subscriptionexam.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscriptionexam.SubscriptionTable, subscriptionexam.SubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExam queries the exam edge of a SubscriptionExam.
func (c *SubscriptionExamClient) QueryExam(se *SubscriptionExam) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := se.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscriptionexam.Table, subscriptionexam.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscriptionexam.ExamTable, subscriptionexam.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(se.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionExamClient) Hooks() []Hook {
	return c.hooks.SubscriptionExam
}

// Interceptors returns the client interceptors.
func (c *SubscriptionExamClient) Interceptors() []Interceptor {
	return c.inters.SubscriptionExam
}

func (c *SubscriptionExamClient) mutate(ctx context.Context, m *SubscriptionExamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionExamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionExamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionExamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SubscriptionExam mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAttempts queries the attempts edge of a User.
func (c *UserClient) QueryAttempts(u *User) *ExamAttemptQuery {
	query := (&ExamAttemptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(examattempt.Table, examattempt.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AttemptsTable, user.AttemptsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(u *User) *UserSubscriptionQuery {
	query := (&UserSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersubscription.Table, usersubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayments queries the payments edge of a User.
func (c *UserClient) QueryPayments(u *User) *PaymentQuery {
	query := (&PaymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PaymentsTable, user.PaymentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserSubscriptionClient is a client for the UserSubscription schema.
type UserSubscriptionClient struct {
	config
}

// NewUserSubscriptionClient returns a client for the UserSubscription from the given config.
func NewUserSubscriptionClient(c config) *UserSubscriptionClient {
	return &UserSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersubscription.Hooks(f(g(h())))`.
func (c *UserSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.UserSubscription = append(c.hooks.UserSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersubscription.Intercept(f(g(h())))`.
func (c *UserSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSubscription = append(c.inters.UserSubscription, interceptors...)
}

// Create returns a builder for creating a UserSubscription entity.
func (c *UserSubscriptionClient) Create() *UserSubscriptionCreate {
	mutation := newUserSubscriptionMutation(c.config, OpCreate)
	return &UserSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSubscription entities.
func (c *UserSubscriptionClient) CreateBulk(builders ...*UserSubscriptionCreate) *UserSubscriptionCreateBulk {
	return &UserSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSubscriptionClient) MapCreateBulk(slice any, setFunc func(*UserSubscriptionCreate, int)) *UserSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSubscriptionCreateBulk{err: fmt.Errorf("calling to UserSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSubscription.
func (c *UserSubscriptionClient) Update() *UserSubscriptionUpdate {
	mutation := newUserSubscriptionMutation(c.config, OpUpdate)
	return &UserSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSubscriptionClient) UpdateOne(us *UserSubscription) *UserSubscriptionUpdateOne {
	mutation := newUserSubscriptionMutation(c.config, OpUpdateOne, withUserSubscription(us))
	return &UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSubscriptionClient) UpdateOneID(id int) *UserSubscriptionUpdateOne {
	mutation := newUserSubscriptionMutation(c.config, OpUpdateOne, withUserSubscriptionID(id))
	return &UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSubscription.
func (c *UserSubscriptionClient) Delete() *UserSubscriptionDelete {
	mutation := newUserSubscriptionMutation(c.config, OpDelete)
	return &UserSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSubscriptionClient) DeleteOne(us *UserSubscription) *UserSubscriptionDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSubscriptionClient) DeleteOneID(id int) *UserSubscriptionDeleteOne {
	builder := c.Delete().Where(usersubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSubscriptionDeleteOne{builder}
}

// Query returns a query builder for UserSubscription.
func (c *UserSubscriptionClient) Query() *UserSubscriptionQuery {
	return &UserSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSubscription entity by its id.
func (c *UserSubscriptionClient) Get(ctx context.Context, id int) (*UserSubscription, error) {
	return c.Query().Where(usersubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSubscriptionClient) GetX(ctx context.Context, id int) *UserSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSubscription.
func (c *UserSubscriptionClient) QueryUser(us *UserSubscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersubscription.Table, usersubscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersubscription.UserTable, usersubscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscription queries the subscription edge of a UserSubscription.
func (c *UserSubscriptionClient) QuerySubscription(us *UserSubscription) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersubscription.Table, usersubscription.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersubscription.SubscriptionTable, usersubscription.SubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayments queries the payments edge of a UserSubscription.
func (c *UserSubscriptionClient) QueryPayments(us *UserSubscription) *PaymentQuery {
	query := (&PaymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersubscription.Table, usersubscription.FieldID, id),
			sqlgraph.To(payment.Table, payment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usersubscription.PaymentsTable, usersubscription.PaymentsColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSubscriptionClient) Hooks() []Hook {
	return c.hooks.UserSubscription
}

// Interceptors returns the client interceptors.
func (c *UserSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.UserSubscription
}

func (c *UserSubscriptionClient) mutate(ctx context.Context, m *UserSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserSubscription mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		CachedExam, Exam, ExamAssesment, ExamAttempt, ExamCategory, ExamSetting,
		GeneratedExam, Payment, Subscription, SubscriptionExam, User,
		UserSubscription []ent.Hook
	}
	inters struct {
		CachedExam, Exam, ExamAssesment, ExamAttempt, ExamCategory, ExamSetting,
		GeneratedExam, Payment, Subscription, SubscriptionExam, User,
		UserSubscription []ent.Interceptor
	}
)
